# 多线程

## 进程和线程

* 进程：进程是资源分配的基本单位。是程序执行的实体
* 线程：线程是cpu调度的基本单位。进程里面包含多个线程。

关系如图所示

整个电脑管家是一个进程。

线程是电脑管家里面的某个功能。

上述关系可以概述为，进程是一个软件，线程是软件里某个特定的功能。

![image-20240708133930369](images/多线程.assets/image-20240708133930369.png)

一个软件有多个线程就是多线程。

## 多线程的应用场景

* 文件的拷贝，迁移
* 加载大量的资源文件
* 聊天软件
* 后台服务器

![image-20240708134741064](images/多线程.assets/image-20240708134741064.png)

 

## 线程的创建

### 1.继承Thread类

```java
/**
 * 创建线程的第一种方式
 * 1.继承Thread类
 * 2.重写run方法
 * 3.创建线程
 * 4.启动线程
 *
 */
public class Threaddemo extends Thread{
    @Override
    public void run() {
        //编写线程的业务，如打印20次线程的名字
        for(int i = 0; i < 20; i ++){
            System.out.println(("我是"+getName()));
        }

    }

    public static void main(String[] args) {
        Threaddemo t1 = new Threaddemo();
        Threaddemo t2 = new Threaddemo();
//        System.out.println(t1.getName());  Thread-0
//        System.out.println(t2.getName());  Thread-1
        t1.start();
        t2.start();
    }
}

```

![image-20240708141932203](images/多线程.assets/image-20240708141932203.png)

看执行结果，是线程0和线程1交替执行的（并发执行）。

* 并发： 统一时间间隔内，多个线程同时执行（宏观上是同时，起始是交替执行）。
* 并行：统一时刻，多个线程同时执行。（多个cpu 执行多个线程）。

### 2.实现Runnable类

```java

/**
 * 创建线程的第二种方式
 * 1.自定义类实现Runnable类
 * 2.重写run方法
 * 3.创建自定义类
 * 4.创建Thread类 并传参，参数是自定义类  现在才是线程
 * 5.启动线程
 *
 */
public class Threaddemo1 implements  Runnable {
    @Override
    public void run() {
        //该线程业务
        //打印20次该线程的名字
        /*
        由于该类是继承Runnable类Runnable还不是线程，需要将该类作为参数给Thread类，才能成为线程
        要先获取线程的名字，要先获得线程。
        * */
        Thread thread = Thread.currentThread();
        for(int i = 0; i < 20; i ++){
            System.out.println("我是"+thread.getName());
        }
    }

    public static void main(String[] args) {
        Threaddemo1 threaddemo1 = new Threaddemo1();
        Thread t1 = new Thread(threaddemo1);
        Thread t2 = new Thread(threaddemo1);
        t1.start();
        t2.start();
    }
}

```

执行如下

![image-20240708144121694](images/多线程.assets/image-20240708144121694.png)

线程并发执行。

### 3.利用Callable接口和Future接口

```java
/**
 * 实现线程的第三种方式
 *      z
 * 利用 Callable接口和 Future 接口方式 实现
 *      这种方式可以获取线程的返回结果，前两种的返回值都是void。
 * 1.自定义类实现Callable接口 ,指定返回的类型给泛型，重写Call方法（业务）
 * 2.创建自定义类对象
 * 2.创建FutureTask 对象（管理call的返回结果）
 */
public class Threaddemo2 implements Callable<Integer> {
    /**
     * 1到100的和
     * @return
     * @throws Exception
     */
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i < 100; i++) {
            sum += i;
        }
        return sum;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Threaddemo2 threaddemo2 = new Threaddemo2();
        FutureTask<Integer> ft = new FutureTask<>(threaddemo2);
        Thread t1 = new Thread(ft);
        t1.start();
        Integer i = ft.get();
        System.out.println(i);
    }
}
```

![image-20240708145057688](images/多线程.assets/image-20240708145057688.png)